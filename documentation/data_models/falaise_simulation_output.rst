Falaise simulation output data
==============================

The simulated data format
-------------------------

Following    the    example     of    the    generic    Bayeux/mctools
``bxg4_production``  program,  the   ``flsimulate``  program  uses  an
embedded      Geant4      simulation     session      driver:      the
``mctools::g4::manager`` class from the Bayeux/mctools module.

The output of this Geant4 driver  -- depending on the configuration of
the  simulated  setup,  associated   physics  and  many  configuration
parameters -- consists in the production of several collections of *MC
true hits*  (instances of  the ``mctools::base_step_hit``  class, also
from the Bayeux/mctools).  Each such  collection is stored as an entry
of a dictionnary and addressed by an unique key, the *hit category* of
the collection (``std::string``). Typical examples are:

  * the ``"gg"`` hit category: used to  store special true hits in the
    SuperNEMO tracker drift cells operating in Geiger mode.
  * the ``"calo"``  hit category: used  to store special true  hits in
    the scintillator blocks of the SuperNEMO calorimeter main walls.
  * the ``"xcalo"`` hit  category: used to store special  true hits in
    the scintillator blocks of the SuperNEMO calorimeter X-walls.
  * the ``"gveto"`` hit  category: used to store special  true hits in
    the scintillator blocks of the SuperNEMO gamma veto.
  * the ``"__visu.tracks"`` hit  category: used to store  true hits to
    enable the display of particle tracks.

The name of such hit category is  set when one configures the back end
hit processors of the Geant4 driver (see for example the configuration
file    of   the    SuperNEMO   tracker    commissioning   simulation:
``resources/config/snemo/tracker_commissioning/simulation/control/1.0/step_hit_processor_factory.conf``).

The  collection  of  hits  are   stored  in  a  dedicated  data  model
implemented  by  the  ``mctools::simulated_data``  class,  beside  the
primary input of the simulation process,  namely:

  * a common vertex (as a ``geomtools::vertex_3d`` instance)
  * a list of primary particles with the full initial kinematics (as a
    ``genbb::primary_event``).

The      ``mctools::simulated_data``      class      inherits      the
``datatools::i_serializable`` interface and thus can be stored in (and
loaded from) a Boost archive which  is the standard I/O medium used in
Bayeux/Falaise. The layout of an  output data file from ``flsimulate``
is (in pseudo-XML): ::

  <simulated_data_1 />
  <simulated_data_2 />
  <simulated_data_3 />
  <simulated_data_4 />
  ...
  <simulated_data_N />

where  *simulated data*  records  are  stored  sequentially,  one  per
archive, whatever the archive is : ASCII, XML, portable binary archive
or the Bayeux/brio I/O system.


The simulated data and the SuperNEMO pipeline event record data model
---------------------------------------------------------------------

One must notice  that the *simulated_data* data model is  not the same
as the data model used for the SuperNEMO pipeline system. The pipeline
uses   a  generic   data   model  implemented   by   objects  of   the
``datatools::things`` class. As a consequence, a file generated by the
``flsimulate`` application can not be read  *as is* by the pipeline; a
dedicated input module is needed  to load the *simulated data* objects
and transfer  them as dedicated  *data banks* of the  pipeline's event
record model.


Using the simulated data format
--------------------------------

Once  generated, the  simulated  data can  be read  by  a third  party
application.    A  dedicated   reader   class  is   provided  by   the
Bayeux/mctools library :  the ``mctools::simulated_data_reader`` class
that is  able to  read plain ``mctools::simulated_data``  objects from
Boost archive files (ASCII, XML, portable binary of Brio).

Another way of processing plain simulated  data stored in a file is to
use    the    ``mctools::simulated_data_input_module``   (also    from
Bayeux/mctools)   from    the   SuperNEMO   pipeline    system.    The
``mctools::simulated_data_input_module``      class      embeds      a
``mctools::simulated_data_reader`` object and uses  it to create a new
``"SD"`` data  bank in  the event  data record.   Such a  module being
typically the first loaded in a pipeline module chain, next modules in
the chain  are thus  free to  use the newly  created ``"SD"``  bank to
access the simulated data model to perform reconstruction operations.
