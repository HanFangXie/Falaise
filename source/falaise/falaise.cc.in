// falaise/falaise.cc - Implementation of falaise init function
//
// Copyright (c) 2013 by Ben Morgan <bmorgan.warwick@gmail.com>
// Copyright (c) 2013 by The University of Warwick
// Copyright (c) 2013 by Francois Mauger <mauger@lpccaen.in2p3.fr>
// Copyright (c) 2013 by Universit√© de Caen
//
// This file is part of Falaise.
//
// Falaise is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Falaise is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Falaise.  If not, see <http://www.gnu.org/licenses/>.

// Standard library
#include <iostream>

// Third party
// - Bayeux
#include <bayeux/bayeux.h>
// Tests
// - datatools
#include <bayeux/datatools/exception.h>
#include <bayeux/datatools/kernel.h>
#include <bayeux/datatools/library_info.h>

// Ourselves
#include "falaise/falaise.h"
#include "falaise/version.h"
#include "falaise/resource.h"

#cmakedefine01 Bayeux_EMBEDDED

namespace {

  void falaise_initialize_impl()
  {
    DT_THROW_IF(!datatools::kernel::is_instantiated(),
                std::runtime_error,
                "The Bayeux/datatools kernel is not instantiated !");
    datatools::kernel & krnl = datatools::kernel::instance();

    // Populate the library info register:
    if (krnl.has_library_info_register()) {
      // Registration of the datatools component in the
      // kernel's library info register:
      datatools::library_info & lib_info_reg
        = krnl.grab_library_info_register();
      //lib_info_reg.tree_dump(std::cerr, "Bayeux -> Library info register: ", "DEVEL: ");

      // Bundled submodules:
      {
        // Falaise itself:
        DT_THROW_IF (lib_info_reg.has("falaise"),
                     std::logic_error,
                     "falaise is already registered !");
        datatools::properties & falaise_lib_infos
          = lib_info_reg.registration("falaise",
                                      "Falaise provides the main computational environment for the simulation,"
                                      "processing and analysis of data for the SuperNEMO double beta decay "
                                      "search experiment.",
                                      falaise::version::get_version()
                                      );

        // Register the Falaise resource path in the datatools' kernel:
        falaise_lib_infos.store_string(datatools::library_info::keys::install_resource_dir(),
                                       falaise::get_resource_dir(false)
                                       );

        // If the 'FALAISE_RESOURCE_DIR' environment variable is set, it will supersed
        // the official registered resource path above through the 'datatools::fetch_path_with_env'
        // function:
        falaise_lib_infos.store_string(datatools::library_info::keys::env_resource_dir(),
                                       "FALAISE_RESOURCE_DIR"
                                       );
      }
    }
    return;
  }

  void falaise_terminate_impl()
  {
    if (datatools::kernel::is_instantiated()) {
      datatools::kernel & krnl = datatools::kernel::instance();
      if (krnl.has_library_info_register()) {
        // Access to the datatools kernel library info register:
        datatools::library_info & lib_info_reg = krnl.grab_library_info_register();

        // Unregistration of all registered submodules from the kernel's
        // library info register:
        if (lib_info_reg.has("falaise")) {
          lib_info_reg.unregistration("falaise");
        }
      }
    }
    return;
  }

}

namespace falaise {

  bool bayeux_embedded()
  {
#if Bayeux_EMBEDDED == 1
    return true;
#else
    return false;
#endif
  }

//   void bayeux_resource_dir(std::string & bx_resource_dir_, bool & bx_system_)
//   {
// #if Bayeux_EMBEDDED == 1
//     // Determine Bayeux's resource path relatively to Falaise resource path
//     // whatever mode we use: build mode or completed installation:
//     // DT_LOG_TRACE(datatools::logger::PRIO_TRACE,
//                   "Guessing embedded Bayeux resource directory relatively to Falaise resource directory...");
//     bx_resource_dir_ = FLSimulate::getResourceDir() + "/../Bayeux-1.0.0/resources";
//     bx_system_ = false;
// #else
//     // Here we use the installed Bayeux's resource path:
//     std::string bx_res_path = "@bayeux:";
//     bx_system_ = true;
//     if (datatools::fetch_path_with_env(bx_res_path)){
//       // DT_LOG_TRACE(datatools::logger::PRIO_TRACE, "Using system Bayeux resource installation directory...");
//       bx_resource_dir_ = bx_res_path;
//     } else {
//       DT_THROW_IF(true, std::runtime_error, "Cannot determine the system Bayeux's resource installation directory!");
//     }
// #endif
//     return;
//   }

  void initialize(int argc_, char * argv_[])
  {
    // Wrap Bayeux initialization because we need resources from various Bayeux's modules:
    ::bayeux::initialize(argc_,argv_);

    // Tests :
    // datatools::kernel & krnl = datatools::kernel::instance();
    // if (krnl.has_library_info_register()) {
    //   datatools::library_info & lib_info_reg
    //     = krnl.grab_library_info_register();
    //   lib_info_reg.tree_dump(std::cerr, "falaise::initialize: Before special initialize", "DEVEL: ");
    // }

    // Initialization code from Falaise itself:
    falaise_initialize_impl();
    return;
  }

  void terminate()
  {
    // Termination code for Falaise:
    falaise_terminate_impl();

    // Wrap Bayeux termination:
    ::bayeux::terminate();

    return;
  }

} // namespace falaise
