<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Falaise: Writing FLReconstruct Modules</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Falaise
   &#160;<span id="projectnumber">4.0.1</span>
   </div>
   <div id="projectbrief">SuperNEMO Software Toolkit</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Writing FLReconstruct Modules </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="introduction"></a>
Introduction to the writing of FLReconstruct modules </h1>
<p>If you have just started using Falaise or the FLReconstruct application, we strongly recommend that you familiarize yourself with the basic usage of FLReconstruct covered in <a class="el" href="usingflreconstruct.html">The FLReconstruct Application</a>.</p>
<p>FLReconstruct uses a <a href="http://en.wikipedia.org/wiki/Pipeline_%28software%29">pipeline pattern</a> to process events. You can view this as a production line with each stage on the line performing some operation on the event. Each stage in the pipeline is called a "pipeline module" (or just "module") and is implemented as a C++ class. The FLReconstruct application can load new modules at runtime using a <a href="http://en.wikipedia.org/wiki/Plug-in_%28computing%29">"plugin" mechanism</a>. Scripting, as demonstrated in the <a class="el" href="usingflreconstruct.html">tutorial on using FLReconstruct</a>, is used to load new modules from plugins, select the modules to use in the pipeline, and configure each module.</p>
<p>In this tutorial we will see how to implement our own modules for use in the FLReconstruct pipeline. This will cover</p>
<ol type="1">
<li>Writing a basic C++ module class</li>
<li>Compiling the class into a plugin for use by FLReconstruct</li>
<li>Scripting for use of the plugin by FLReconstruct</li>
<li>Implementing runtime module configuration</li>
</ol>
<p>Getting your module to actually do something with the events that are passed to it is deferred to <a class="el" href="workingwitheventrecords.html">a later tutorial</a>.</p>
<h1><a class="anchor" id="minimalmodule"></a>
Implementing a Minimal flreconstruct Module </h1>
<h2><a class="anchor" id="minimalmodule_sources"></a>
Creating the Module Source Code </h2>
<p>We begin by creating an empty directory to hold the source code for our example module, which we'll name "MyModule"</p>
<div class="fragment"><div class="line">$ cd MyWorkSpace</div><div class="line">$ mkdir MyModule</div><div class="line">$ cd MyModule</div><div class="line">$ ls</div><div class="line">$</div></div><!-- fragment --><p>You are free to organise the source code under this directory as you see fit. In this very simple case we will just place all files in the <code>MyModule</code> directory without any subdirectories. We start by creating the implementation file, for the C++ class, which we'll name <code>MyModule.cpp</code></p>
<div class="fragment"><div class="line"><span class="comment">// Interface from Falaise</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="module_8h.html">falaise/snemo/processing/module.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyModule {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Default constructor</span></div><div class="line">  MyModule() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  <span class="comment">// User-defined Constructor</span></div><div class="line">  MyModule(<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> <span class="keyword">const</span>&amp; <span class="comment">/*ps*/</span>,</div><div class="line">           <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a>&amp; <span class="comment">/*services*/</span>) {</div><div class="line">  }</div><div class="line"></div><div class="line">  <span class="comment">// Process event</span></div><div class="line">  <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdpp_1_1base__module.html#ae8431b8f4f2734bae557791b9f5417fb">falaise::processing::status</a> process(<a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1things.html">datatools::things</a>&amp; <span class="comment">/*e*/</span>) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;MyModule::process called!\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> falaise::processing::status::PROCESS_OK;</div><div class="line">  }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="comment">// Register module with Falaise&#39;s plugin system on load</span></div><div class="line"><a class="code" href="module_8h.html#a63c0e69cd4edd7150e04dd18e3de1358">FALAISE_REGISTER_MODULE</a>(MyModule)</div><div class="line"></div></div><!-- fragment --><p>Here we can see the minimal interface and infrastructure required by a module class for <code>flreconstruct</code>. The class must implement:</p>
<ul>
<li>A default constructor</li>
<li>A non-default constructor taking parameters:<ul>
<li><code><a class="el" href="classfalaise_1_1config_1_1property__set.html" title="Class holding a set of key-value properties.">falaise::config::property_set</a> const&amp;</code>, the configuration supplied to the module by the pipeline script</li>
<li><code><a class="elRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a>&amp;</code>, <code>flreconstruct</code>'s service provider</li>
</ul>
</li>
<li>A public member function <code>process</code> taking a single <code><a class="elRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1things.html">datatools::things</a>&amp;</code> input parameter, and returning a <a class="el" href="namespacefalaise_1_1processing.html#ae017f352999f7a267a0d3094b8573774">falaise::processing::status</a> enumeration.</li>
</ul>
<p>To make the plugin we'll build from this code loadable by <code>flreconstruct</code> we must also use the <a class="el" href="module_8h.html#a63c0e69cd4edd7150e04dd18e3de1358">FALAISE_REGISTER_MODULE</a> macro, passing it the class's typename. This will also become a string that can be used to create a module of this type in an <code>flreconstruct</code> pipeline script.</p>
<p>The non-default constructor is responsible for initializing the module using, if required, the information supplied in the <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> and <a class="elRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a> objects. Our basic module doesn't require any configuration or service information so we simply ignore these arguments. Later tutorials will cover <a class="el" href="writingflreconstructmodules.html#minimalconfigurablemodule">module configuration</a> and <a class="el" href="usingservices.html">use of services by modules</a>.</p>
<p>The <code>process</code> member function performs the actual operation on the event, which is represented by a <a class="elRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1things.html">datatools::things</a> instance. It is passed via non-const reference so <code>process</code> can both read and write data to the event. As noted above, <a class="el" href="workingwitheventrecords.html">a later tutorial</a> will cover the interface and use of <a class="elRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1things.html">datatools::things</a>. We therefore don't do anything with the event, and simply write a message to standard output so that we'll be able to see the method being called in <code>flreconstruct</code>. <code>process</code> <b>must</b> return a <a class="el" href="namespacefalaise_1_1processing.html#ae017f352999f7a267a0d3094b8573774">processing exit code</a>. In this case, our processing is always successful, so we return <code>falaise::processing::status::PROCESS_OK</code>.</p>
<h2><a class="anchor" id="minimalmodulebuilding"></a>
Building the Loadable Shared Library </h2>
<p>With the source code for <code>MyModule</code> in place we need to build a shared library from it that <code>flreconstruct</code> can load at runtime to make <code>MyModule</code> usable in a pipeline. As <code>MyModule</code> uses components from Falaise, the compilation needs to use its headers, libraries and dependencies. The simplest way to set this up is to use <a href="https://cmake.org">CMake</a> to build the shared library and make use of Falaise's <a href="https://cmake.org/cmake/help/v3.9/command/find_package.html">find_package</a> support.</p>
<p>To do this, we add a CMake script alongside the sources:</p>
<div class="fragment"><div class="line">$ ls</div><div class="line">MyModule.cpp</div><div class="line">$ touch CMakeLists.txt</div><div class="line">$ ls</div><div class="line">CMakeLists.txt MyModule.cpp</div><div class="line">$</div></div><!-- fragment --><p>The implementation of <code>CMakeLists.txt</code> is very straightforward:</p>
<div class="fragment"><div class="line"><span class="preprocessor"># Check cmake version meets our requirements</span></div><div class="line">cmake_minimum_required(VERSION 3.9)</div><div class="line"></div><div class="line"><span class="preprocessor"># Declare project, which will configure compiler for us</span></div><div class="line">project(MyModule)</div><div class="line"></div><div class="line"><span class="preprocessor"># Modules use Falaise, so we need to locate this or fail</span></div><div class="line"><span class="preprocessor"># Locating Falaise will automatically locate all of its</span></div><div class="line"><span class="preprocessor"># dependencies such as Bayeux, ROOT and Boost.</span></div><div class="line">find_package(Falaise REQUIRED)</div><div class="line"></div><div class="line"><span class="preprocessor"># Build a shared/dynamic library from our source</span></div><div class="line">add_library(MyModule SHARED MyModule.cpp)</div><div class="line"></div><div class="line"><span class="preprocessor"># Link this library to the FalaiseModule library</span></div><div class="line"><span class="preprocessor"># This ensures the correct compiler flags, include paths</span></div><div class="line"><span class="preprocessor"># and linker flags are used to compile our library.</span></div><div class="line">target_link_libraries(MyModule Falaise::FalaiseModule)</div><div class="line"></div></div><!-- fragment --><p>Comments begin with a <code>#</code>. The first two commands simply setup CMake and the compiler for us. The <code>find_package</code> command will locate Falaise for us, and we supply the <code>REQUIRED</code> argument to ensure CMake will fail if a Falaise install cannot be found. The <code>add_library</code> command creates the actual shared library. Breaking the arguments to <code>add_library</code> down one by one:</p>
<ol type="1">
<li><code>MyModule</code> : the name of the library, which will be used to create the on disk name. For example, on Linux, this will output a library file <code>libMyModule.so</code>, and on Mac OS X a library file <code>libMyModule.dylib</code>.</li>
<li><code>SHARED</code> : the type of the library, in this case a dynamic library.</li>
<li><code>MyModule.cpp</code> : all the sources need to build the library.</li>
</ol>
<p>Finally, the <code>target_link_libraries</code> command links the shared library to Falaise's <code>Falaise::FalaiseModule</code> target. This ensures that compilation and linking of the <code>MyModule</code> target will use the correct compiler and linker flags for use of Falaise. The <code>flreconstruct</code> application makes a default set of libraries available, and if you require use of additional ones, CMake must be set up to find and use these. This is documented <a class="el" href="writingflreconstructmodules.html#additionallibraries">later in this tutorial</a>.</p>
<p>For more detailed documentation on CMake, please refer to its <a href="https://cmake.org/cmake/help/latest/">online help</a>.</p>
<p>To build the library, we first create a so-called <em>build directory</em> to hold the files generated by the compilation to isolate them from the source code. This means we can very quickly delete and recreate the build without worrying about deleting the primary sources (it also helps to avoid accidental commits of local build artifacts to Git!). This directory can be wherever you like, but it's usually most convenient to create it alongside the directory in which the sources reside. In this example we have the directory structure:</p>
<div class="fragment"><div class="line">$ pwd</div><div class="line">/path/to/MyWorkSpace</div><div class="line">$ tree .</div><div class="line">.</div><div class="line">`-- MyModule</div><div class="line">  |-- CMakeLists.txt</div><div class="line">  `-- MyModule.cpp</div><div class="line"></div><div class="line">1 directory, 2 files</div><div class="line">$</div></div><!-- fragment --><p>so we create the build directory under <code>/path/to/MyWorkSpace</code> as</p>
<div class="fragment"><div class="line">$ mkdir MyModule-build</div><div class="line">$ tree .</div><div class="line">.</div><div class="line">|-- MyModule</div><div class="line">|  |-- CMakeLists.txt</div><div class="line">|  `-- MyModule.cpp</div><div class="line">`-- MyModule-build</div><div class="line"></div><div class="line">2 directories, 2 files</div><div class="line">$</div></div><!-- fragment --><p>The first step of the build is to change into the build directory and run <code>cmake</code> to configure the build of <code>MyModule</code>:</p>
<div class="fragment"><div class="line">$ cd MyModule-build</div><div class="line">$ cmake -DCMAKE_PREFIX_PATH=/where/Falaise/is ../MyModule</div></div><!-- fragment --><p>Here, the <code>CMAKE_PREFIX_PATH</code> argument should be the directory under which Falaise was installed. If you installed Falaise using <code>brew</code> and are using the <code>snemo-shell</code> environment then you will not need to set this. The last argument <code>../MyModule</code> points CMake to the directory holding the <code>CMakeLists.txt</code> file for the project we want to build, in this case our custom module.</p>
<p>Running the command will produce output that is highly system dependent, but you should see something along the lines of</p>
<div class="fragment"><div class="line">$ cmake -DCMAKE_PREFIX_PATH=/where/Falaise/is ../MyModule</div><div class="line">-- The C compiler identification is AppleClang 10.0.0.10001044</div><div class="line">-- The CXX compiler identification is AppleClang 10.0.0.10001044</div><div class="line">-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc</div><div class="line">-- Check for working C compiler: /Library/Developer/CommandLineTools/usr/bin/cc -- works</div><div class="line">-- Detecting C compiler ABI info</div><div class="line">-- Detecting C compiler ABI info - done</div><div class="line">-- Detecting C compile features</div><div class="line">-- Detecting C compile features - done</div><div class="line">-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++</div><div class="line">-- Check for working CXX compiler: /Library/Developer/CommandLineTools/usr/bin/c++ -- works</div><div class="line">-- Detecting CXX compiler ABI info</div><div class="line">-- Detecting CXX compiler ABI info - done</div><div class="line">-- Detecting CXX compile features</div><div class="line">-- Detecting CXX compile features - done</div><div class="line">...</div><div class="line">-- Configuring done</div><div class="line">-- Generating done</div><div class="line">-- Build files have been written to: /..../MyModule-build</div><div class="line">$</div></div><!-- fragment --><p>The exact output will depend on which compiler and platform you are using. However, the last three lines are common apart from the path, and indicate a successful configuration. Listing the contents of the directory shows that CMake has generated a Makefile for us:</p>
<div class="fragment"><div class="line">$ ls</div><div class="line">CMakeCache.txt CMakeFiles cmake_install.cmake Makefile</div><div class="line">$</div></div><!-- fragment --><p>To build the library for our module we simply run <code>make</code>:</p>
<div class="fragment"><div class="line">$ make</div><div class="line">Scanning dependencies of target MyModule</div><div class="line">[ 50%] Building CXX object CMakeFiles/MyModule.dir/MyModule.cpp.o</div><div class="line">[100%] Linking CXX shared library libMyModule.dylib</div><div class="line">[100%] Built target MyModule</div><div class="line">$</div></div><!-- fragment --><p>If the build succeeds, we now have the shared library present in our build directory:</p>
<div class="fragment"><div class="line">$ ls</div><div class="line">CMakeCache.txt   CMakeFiles     Makefile      cmake_install.cmake libMyModule.dylib</div><div class="line">$</div></div><!-- fragment --><p>Note that the extension of the shared library is platform dependent (<code>.dylib</code> for Mac, <code>.so</code> on Linux). With the library built, we now need to make <code>flreconstruct</code> aware of it so we can use <code>MyModule</code> in a pipeline.</p>
<h2><a class="anchor" id="minimalmodulerunning"></a>
Running flreconstruct With a Custom Module </h2>
<p>To use our new module in <code>flreconstruct</code> we need to tell the application about it before using it in a pipeline. We do this through the pipeline script we pass to <code>flreconstruct</code> via</p>
<ol type="1">
<li>Adding a new section named <code>flreconstruct.plugins</code> which tells <code>flreconstruct</code> about libraries to be loaded.</li>
<li>Adding a section declaring our module</li>
</ol>
<p>We create a script named <code>MyModulePipeline.conf</code> in our project directory:</p>
<div class="fragment"><div class="line">$ pwd</div><div class="line">/path/to/MyWorkSpace/MyModule</div><div class="line">$ ls</div><div class="line">CMakeLists.txt MyModule.cpp MyModulePipeline.conf</div></div><!-- fragment --><p>This script takes the same basic form as shown in the <a class="el" href="usingflreconstruct.html">tutorial on using flreconstruct</a>:</p>
<div class="fragment"><div class="line"># - Configuration Metadata</div><div class="line">#@description Chain pipeline using a single custom module</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line"># The &quot;flreconstruct.plugins&quot; section to tell flreconstruct what</div><div class="line"># to load and from where.</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;.&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line"># Must define &quot;pipeline&quot; as this is the main module flreconstruct will use</div><div class="line"># Make it use our custom module by setting the &#39;type&#39; key to its typename</div><div class="line"># At present, it takes no configuration, so it suffices to declare it</div><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>The <code>plugins</code> key in the <code>flreconstruct.plugins</code> section is a list of strings naming the libraries to be loaded by <code>flreconstruct</code> at startup. These are taken as the "basename" of the library, from which the full physical file to be loaded, <code>lib&lt;basename&gt;.{so,dylib}</code>, is constructed. <code>flreconstruct</code> only searches for plugin libraries in its builtin location by default, so custom modules must set the <code>&lt;basename&gt;.directory</code> property to tell it the path under which their <code>&lt;basename&gt;</code> library is located.</p>
<p>In the above example, <code>MyModule.directory : string ="."</code> tells <code>flreconstruct</code> to look in the current working directory, i.e. the directory from which it was run, for the <code>MyModule</code> plugin. This is convenient for testing a local build of a module, as we can run <code>flreconstruct</code> directly from the build directory of our module and it will locate the library immediately. You can also specify absolute paths, e.g.</p>
<div class="fragment"><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;/path/to/MyWorkSpace/MyModule-build&quot;</div></div><!-- fragment --><p>or paths containing environment variables which will be expanded automatically, e.g.</p>
<div class="fragment"><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;${MYMODULE_PATH}&quot;</div></div><!-- fragment --><p>With the loading of the custom module in place, we can use it in the script as we did for the builtin modules. As we did in in the <a class="el" href="writingflreconstructpipelinescripts.html#trivial_pipeline">trivial pipeline example for flreconstruct</a>, we can simply declare the main pipeline module as being of the <code>MyModule</code> type, hence the line</p>
<div class="fragment"><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div></div><!-- fragment --><p>Note that the <code>type</code> key value must always be the full typename of the module, as used in the <a class="el" href="module_8h.html#a63c0e69cd4edd7150e04dd18e3de1358">FALAISE_REGISTER_MODULE</a> macro. Remember that in <code>MyModule.cpp</code> we called the macro as:</p>
<div class="fragment"><div class="line"><a class="code" href="module_8h.html#a63c0e69cd4edd7150e04dd18e3de1358">FALAISE_REGISTER_MODULE</a>(MyModule);</div></div><!-- fragment --><p>thus <code>type</code> is just "MyModule".</p>
<p>We can now run <code>flreconstruct</code> with <code>MyModulePipeline.conf</code> as the pipeline script. Because we've specified the location of the <code>MyModule</code> library as the working directory, we first change to the directory in which this library resides, namely our build directory. We also need to have a file to process, so we run <code>flsimulate</code> first to create a simple file of one event (NB in the following, we assume you have <code>flsimulate</code> and <code>flreconstruct</code> in your <code>PATH</code>).</p>
<div class="fragment"><div class="line">$ cd /path/to/MyWorkSpace/MyModule-build</div><div class="line">$ ls</div><div class="line">CMakeCache.txt CMakeFiles cmake_install.cmake libMyModule.dylib Makefile</div><div class="line">$ flsimulate -o MyModuleTest.brio</div><div class="line">....</div><div class="line">$ ls</div><div class="line">CMakeCache.txt cmake_install.cmake Makefile</div><div class="line">CMakeFiles   libMyModule.dylib    MyModuleTest.brio</div><div class="line">$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModulePipeline.conf</div><div class="line">[notice:void datatools::library_loader::init():449] Automatic loading of library &#39;MyModule&#39;...</div><div class="line">MyModule::process called!</div><div class="line">$</div></div><!-- fragment --><p>We can see that <code>flreconstruct</code> loaded the <code>MyModule</code> library, and the <code>MyModule::process</code> method was called, showing that the pipeline used our custom module! We can also add our module into a chain pipeline and other pipeline structures. For example, try the following pipeline script:</p>
<div class="fragment"><div class="line"># - Configuration</div><div class="line">#@description Simple pipeline using a chain</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Module load section</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;.&quot;</div><div class="line"></div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line">[name=&quot;pipeline&quot; type=&quot;dpp::chain_module&quot;]</div><div class="line">modules : string[3] = &quot;start_module&quot; &quot;dump&quot; &quot;end_module&quot;</div><div class="line"></div><div class="line">[name=&quot;start_module&quot; type=&quot;MyModule&quot;]</div><div class="line"></div><div class="line">[name=&quot;dump&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line"></div><div class="line">[name=&quot;end_module&quot; type=&quot;MyModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>You should see each event being dumped, with the dumped info being bracketed by the <code>MyModule::process called!</code> text from each of the <code>MyModule</code> instances in the chain.</p>
<h1><a class="anchor" id="minimalconfigurablemodule"></a>
Making Your Module Configurable </h1>
<p>The minimal module presented in <a class="el" href="writingflreconstructmodules.html#minimalmodule">the section above</a> outputs a fixed message which can only be changed by modifying the code and recompiling the module. In most use cases hard-coding like this is sufficient, but if your module has parameters that may change frequently (e.g. a threshold that requires optimization), it is easy to make them configurable at runtime through the pipeline script. To demonstrate this, we'll modify the <code>MyModule</code> class from earlier to have a single <code>std::string</code> type data member and make this configurable from the pipeline script.</p>
<h2><a class="anchor" id="minimalconfigurablemodulecpp"></a>
Adding a Configurable Data Member </h2>
<p>To add a configurable data member to <code>MyModule</code>, we modify the code as follows:</p>
<div class="fragment"><div class="line"><span class="comment">// Interface from Falaise</span></div><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="module_8h.html">falaise/snemo/processing/module.h</a>&quot;</span></div><div class="line"></div><div class="line"><span class="keyword">class </span>MyModule {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MyModule() = <span class="keywordflow">default</span>;</div><div class="line"></div><div class="line">  MyModule(<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> <span class="keyword">const</span>&amp; ps,</div><div class="line">           <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a>&amp; <span class="comment">/*services*/</span>)</div><div class="line">      : message(ps.<a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/namespacedatatools.html#ab059bac0563dc9603cab716ab14010f4">get</a>&lt;std::string&gt;(<span class="stringliteral">&quot;message&quot;</span>)) {}</div><div class="line"></div><div class="line">  <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdpp_1_1base__module.html#ae8431b8f4f2734bae557791b9f5417fb">falaise::processing::status</a> process(<a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1things.html">datatools::things</a>&amp; <span class="comment">/*workItem*/</span>) {</div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;MyModule::process says &#39;&quot;</span> &lt;&lt; message &lt;&lt; <span class="stringliteral">&quot;&#39;\n&quot;</span>;</div><div class="line">    <span class="keywordflow">return</span> falaise::processing::status::PROCESS_OK;</div><div class="line">  }</div><div class="line"></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::string message{};</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="module_8h.html#a63c0e69cd4edd7150e04dd18e3de1358">FALAISE_REGISTER_MODULE</a>(MyModule);</div></div><!-- fragment --><p>The key changes are:</p>
<ol type="1">
<li><code>std::string</code> data member <code>message</code></li>
<li>Use of the data member in the <code>process</code> member function</li>
<li>Use of the <a class="el" href="classfalaise_1_1config_1_1property__set.html" title="Class holding a set of key-value properties.">falaise::config::property_set</a> instance <code>ps</code> passed to the user-defined constructor to extract configuration information</li>
</ol>
<p>Here, <code>message</code> is our configurable parameter, and is initialized in the <code>MyModule</code> constructor using the <a class="el" href="classfalaise_1_1config_1_1property__set.html#a2046c76a30b2d2fa0e9bf7262faaf724">falaise::config::property_set::get</a> member function. We supply <code>std::string</code> as the template argument as that is the type we need, and <code>message</code> as the parameter ID to extract. This ID does not have to match the name of the data member, but it is useful to do so for clarity.</p>
<p>As configuration is always done through the constructor, you can then use configured data members just like any other. In this case we simply report the value of <code>message</code> to standard output in the <code>process</code> member function.</p>
<h2>Building a Loadable Shared Library for a Configurable Module </h2>
<p>No special build setup is needed for a configurable module, so you can use the CMake script <a class="el" href="writingflreconstructmodules.html#minimalmodulebuilding">exactly as given for the basic module above</a>. If you've made the changes as above, simply rebuild!</p>
<h2><a class="anchor" id="minimalconfigurablemodulescript"></a>
Configuring MyModule from the Pipeline Script </h2>
<p>In the preceding section, we saw that module configuration is passed to a module through an instance of the <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> class. This instance is created by <code>flreconstruct</code> for the module from the properties, if any, supplied in the section of the pipeline script defining the module. To begin with, we can use the pipeline script from earlier to run the configurable module, simply adding the required string parameter <code>message</code> to its section:</p>
<div class="fragment"><div class="line"># - Configuration Metadata</div><div class="line">#@description Chain pipeline using a single custom module</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line"># The &quot;flreconstruct.plugins&quot; section to tell flreconstruct what</div><div class="line"># to load and from where.</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;.&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line"># Make it use our custom module by setting the &#39;type&#39; key to its typename</div><div class="line"># and supply the required &quot;message&quot; string parameter</div><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line">message : string = &quot;hello&quot;</div><div class="line"></div></div><!-- fragment --><p>The key name <code>message</code> and its type must match that looked for by <code>MyModule</code>'s constructor in the supplied <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a>. Allowed key/types and their mappings to C++ types are documented in <a class="el" href="writingflreconstructmodules.html#configurationbestpractices">a later section</a>. The script can be run in <code>flreconstruct</code> as before:</p>
<div class="fragment"><div class="line">$ cd /path/to/MyWorkSpace/MyModule-build</div><div class="line">$ ls</div><div class="line">CMakeCache.txt cmake_install.cmake Makefile</div><div class="line">CMakeFiles   libMyModule.so    MyModuleTest.brio</div><div class="line">$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModulePipeline.conf</div><div class="line">[notice:void datatools::library_loader::_init():467] Automatic loading of library &#39;MyModule&#39;...</div><div class="line">MyModule::process says &#39;hello&#39;</div><div class="line">$</div></div><!-- fragment --><p>We can see that the module has been run using the supplied value for the parameter. To change the <code>message</code> parameter, we simply update its value, e.g.</p>
<div class="fragment"><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line">message : string = &quot;goodbye&quot;</div></div><!-- fragment --><p> Having add the key, we can rerun with the updated pipeline script:</p>
<div class="fragment"><div class="line">$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModulePipeline.conf</div><div class="line">[notice:void datatools::library_loader::_init():467] Automatic loading of library &#39;MyModule&#39;...</div><div class="line">MyModule::process says &#39;goodbye&#39;</div><div class="line">$</div></div><!-- fragment --><p>and see that the parameter has been changed to the value defined in the script. Keys are bound to the section they are defined in, so we can use the same module type multiple times but with different parameters. For example, try the following pipeline script:</p>
<div class="fragment"><div class="line"># - Configuration Metadata</div><div class="line">#@description Chain pipeline using a single custom module</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line"># The &quot;flreconstruct.plugins&quot; section to tell flreconstruct what</div><div class="line"># to load and from where.</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;.&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line"># Chain dpp::dump_module between two MyModules</div><div class="line">[name=&quot;pipeline&quot; type=&quot;dpp::chain_module&quot;]</div><div class="line">modules : string [3] = &quot;hello&quot; &quot;process&quot; &quot;goodbye&quot;</div><div class="line"></div><div class="line"># - Per Module configurations</div><div class="line">[name=&quot;hello&quot; type=&quot;MyModule&quot;]</div><div class="line">message : string = &quot;hello&quot;</div><div class="line"></div><div class="line">[name=&quot;process&quot; type=&quot;dpp::dump_module&quot;]</div><div class="line"></div><div class="line">[name=&quot;goodbye&quot; type=&quot;MyModule&quot;]</div><div class="line">message :string = &quot;goodbye&quot;</div><div class="line"></div></div><!-- fragment --><p>You should see each event being dumped, with the dumped info being bracketed by the output from each <code>MyModule</code> instance, each with different values of the message parameter.</p>
<p>Both <code>flreconstruct</code> and <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> work together to check that needed parameters are supplied and of the correct type. For example, if we <em>did not</em> supply the <code>message</code> parameter:</p>
<div class="fragment"><div class="line"># - Configuration Metadata</div><div class="line">#@description Chain pipeline using a single custom module</div><div class="line">#@key_label   &quot;name&quot;</div><div class="line">#@meta_label  &quot;type&quot;</div><div class="line"></div><div class="line"># - Custom modules</div><div class="line"># The &quot;flreconstruct.plugins&quot; section to tell flreconstruct what</div><div class="line"># to load and from where.</div><div class="line">[name=&quot;flreconstruct.plugins&quot; type=&quot;flreconstruct::section&quot;]</div><div class="line">plugins : string[1] = &quot;MyModule&quot;</div><div class="line">MyModule.directory : string = &quot;.&quot;</div><div class="line"></div><div class="line"># - Pipeline configuration</div><div class="line"># Must define &quot;pipeline&quot; as this is the module flreconstruct will use</div><div class="line"># Make it use our custom module by setting the &#39;type&#39; key to its typename</div><div class="line"># and leave out the required &quot;message&quot; parameter to illustrate error reporting</div><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line"></div></div><!-- fragment --><p>then <code>flreconstruct</code> will error out and tell us what happened:</p>
<div class="fragment"><div class="line">$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModuleMissingParam.conf</div><div class="line">[notice:void datatools::library_loader::_init():467] Automatic loading of library &#39;MyModule&#39;...</div><div class="line">[fatal:falaise::exit_code FLReconstruct::do_pipeline(const FLReconstruct::FLReconstructParams &amp;):156] Failed to initialize pipeline : initialization of module &#39;pipeline&#39; (type &#39;MyModule&#39;) failed with exception:</div><div class="line">- missing_key_error: property_set does not hold a key &#39;message&#39;</div><div class="line">- config:</div><div class="line">`-- &lt;no property&gt;</div><div class="line"></div><div class="line">$</div></div><!-- fragment --><p>Equally, if we supply the parameter but it has the wrong type:</p>
<div class="fragment"><div class="line">[name=&quot;pipeline&quot; type=&quot;MyModule&quot;]</div><div class="line">message : integer = 42</div></div><!-- fragment --><p>then a similar error would be reported:</p>
<div class="fragment"><div class="line">$ flreconstruct -i MyModuleTest.brio -p ../MyModule/MyModuleWrongType.conf</div><div class="line">[notice:void datatools::library_loader::_init():467] Automatic loading of library &#39;MyModule&#39;...</div><div class="line">[fatal:falaise::exit_code FLReconstruct::do_pipeline(const FLReconstruct::FLReconstructParams &amp;):156] Failed to initialize pipeline : initialization of module &#39;pipeline&#39; (type &#39;MyModule&#39;) failedwith exception:</div><div class="line">- wrong_type_error: value at &#39;message&#39; is not of requested type</div><div class="line">- config:</div><div class="line">`-- Name : &#39;message&#39;</div><div class="line">    |-- Type  : integer (scalar)</div><div class="line">    `-- Value : 42</div><div class="line"></div><div class="line">$</div></div><!-- fragment --><p>Additional methods for configuration and validation are covered in the <a class="el" href="writingflreconstructmodules.html#configurationbestpractices">following section</a>.</p>
<h2><a class="anchor" id="configurationbestpractices"></a>
Best Practices for Module Configuration </h2>
<p>Whilst the ability to make modules configurable is extremely useful, <em>you should aim to minimize the number of parameters your module takes</em>. This helps to make the module easier to use and less error prone. Remember that the modular structure of the pipeline means that tasks are broken down into smaller chunks, so you should consider refactoring complex modules into smaller orthogonal units.</p>
<p>An important restriction on configurable parameters is that they can only be of types understood by <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> and the underlying <a class="elRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1properties.html">datatools::properties</a> configuration language.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">C++ Type  </th><th class="markdownTableHeadNone"><code>property_set</code> accessor  </th><th class="markdownTableHeadNone">properties script syntax   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::string</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;std::string&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : string = "hello"   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>int</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;int&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : integer = 42   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>double</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;double&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : real = 3.14   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>bool</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;bool&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : boolean = true   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::vector&lt;std::string&gt;</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;std::vector&lt;std::string&gt;&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : string[2] = "hello" "world"   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::vector&lt;int&gt;</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;std::vector&lt;int&gt;&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : int[2] = 1 2   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><code>std::vector&lt;double&gt;</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;std::vector&lt;double&gt;&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : real[2] = 3.14 4.13   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><code>std::vector&lt;bool&gt;</code>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;std::vector&lt;bool&gt;&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : bool[2] = true false   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classfalaise_1_1config_1_1path.html">falaise::config::path</a>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;<a class="el" href="classfalaise_1_1config_1_1path.html" title="Class representing a filesystem path as held by a property_set.">falaise::config::path</a>&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : string as path = "/tmp/foo"   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone"><a class="el" href="classfalaise_1_1config_1_1quantity__t.html">falaise::config::quantity_t</a>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;<a class="el" href="classfalaise_1_1config_1_1length__t.html" title="quantity for values with dimension tag length ([L])">falaise::config::length_t</a>&gt;("key");</code>  </td><td class="markdownTableBodyNone">key : real as length = 3.14 mm   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone"><a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a>  </td><td class="markdownTableBodyNone"><code>auto x = ps.get&lt;<a class="el" href="classfalaise_1_1config_1_1property__set.html" title="Class holding a set of key-value properties.">falaise::config::property_set</a>&gt;("key");</code>  </td><td class="markdownTableBodyNone"><em>see below</em>   </td></tr>
</table>
<p>The last item handles the case of nested configurations, for example</p>
<div class="fragment"><div class="line">[name=&quot;nested&quot; type=&quot;NestedModule&quot;]</div><div class="line">a.x : int = 1</div><div class="line">a.y : int = 3</div><div class="line">b.x : int = 2</div><div class="line">b.y : int = 4</div></div><!-- fragment --><p>The keys can be extracted individually from the resultant <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a>, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> x = ps.get&lt;<span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;a.x&quot;</span>);</div></div><!-- fragment --><p>However, nested configurations typically imply structured data, with periods indicating the nesting level. Each level can be extracted into its own set of properties, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">auto</span> a = ps.get&lt;<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a>&gt;(<span class="stringliteral">&quot;a&quot;</span>); <span class="comment">// a now holds key-values x=1, y=3</span></div><div class="line"><span class="keyword">auto</span> b = ps.<a class="code" href="classfalaise_1_1config_1_1property__set.html#a2046c76a30b2d2fa0e9bf7262faaf724">get</a>&lt;<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a>&gt;(<span class="stringliteral">&quot;b&quot;</span>); <span class="comment">// b now holds key-values x=2, y=4</span></div></div><!-- fragment --><p>with subsequent handling as required. A restriction on nesting is that it <em>cannot</em> support configurations such as</p>
<div class="fragment"><div class="line">[name=&quot;nested&quot; type=&quot;BadlyNested&quot;]</div><div class="line">a : int = 1</div><div class="line">a.x : real = 3.14</div></div><!-- fragment --><p>as the key "a" is ambiguous. You should not use this form in any case as it generally indicates bad design.</p>
<p>When using <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a>, you have several methods to <em>validate</em> the configuration supplied to your module. By <em>validation</em>, we mean checking the configuration supplies:</p>
<ol type="1">
<li>The required parameters...</li>
<li>... of the correct type ...</li>
<li>.. in the correct value range</li>
</ol>
<p>All configuration and validation must be handled in the module's constructor, with exceptions thrown if an validation check fails. The first two checks can be handled automatically by <a class="el" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> through its <code>get</code> member functions.</p>
<p>Parameters may be <em>required</em>, i.e. there is no sensible default, or <em>optional</em>, i.e. where we may wish to adjust the default. A required parameter is validated for existence and correct type by the single parameter <code>get</code> member function, e.g.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyModule {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MyModule(<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> <span class="keyword">const</span>&amp; ps, <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a>&amp;)</div><div class="line">   : message( ps.<a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/namespacedatatools.html#ab059bac0563dc9603cab716ab14010f4">get</a>&lt;std::string&gt;(<span class="stringliteral">&quot;message&quot;</span>) )</div><div class="line">  {}</div><div class="line">  <span class="comment">// other code omitted</span></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  std::string message;</div><div class="line">};</div></div><!-- fragment --><p>If the <code>ps</code> instance does not hold a parameter "message", or holds it with a type other than <code>std::string</code>, then an exception is thrown and will be handled automatically by <code>flreconstruct</code>.</p>
<p>An optional parameter is validated in the same way, but we use the two parameter form of <code>get</code>, e.g:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyModule {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MyModule(<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> <span class="keyword">const</span>&amp; ps, <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a>&amp;)</div><div class="line">   : myparam( ps.<a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/namespacedatatools.html#ab059bac0563dc9603cab716ab14010f4">get</a>&lt;int&gt;(<span class="stringliteral">&quot;myparam&quot;</span>, 42) )</div><div class="line">  {}</div><div class="line">  <span class="comment">// other code omitted</span></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> myparam;</div><div class="line">};</div></div><!-- fragment --><p>Here, if the <code>ps</code> instance does not hold a parameter "myparam" then the <code>myparam</code> data member will be initialized to <code>42</code>. If <code>ps</code> holds parameter "myparam" of type <code>int</code> then <code>myparam</code> will be set to its value. If <code>ps</code> holds parameter "myparam" and it is <em>not</em> of type <code>int</code>, then an exception is thrown (and handled by <code>flreconstruct</code> as above). Both forms are particularly useful for parameters that supply physical quantities such as lengths. See the documentation on Falaise's <a class="el" href="group__falaise__units.html">System of Units</a> for further information on their use to assist with dimensional and scaling correctness.</p>
<p>Additional validation tasks such as bounds checking must be handled manually, and generally within the body of the module's constructor. For example, if we have a required integer parameter that must be even, we could validate this via:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyModule {</div><div class="line"> <span class="keyword">public</span>:</div><div class="line">  MyModule(<a class="code" href="classfalaise_1_1config_1_1property__set.html">falaise::config::property_set</a> <span class="keyword">const</span>&amp; ps, <a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/classdatatools_1_1service__manager.html">datatools::service_manager</a>&amp;)</div><div class="line">   : myparam( ps.<a class="codeRef" doxygen="https://supernemo-dbd.github.io/Bayeux/bayeux.doxy.tag:https://supernemo-dbd.github.io/Bayeux/" href="https://supernemo-dbd.github.io/Bayeux/namespacedatatools.html#ab059bac0563dc9603cab716ab14010f4">get</a>&lt;int&gt;(<span class="stringliteral">&quot;myparam&quot;</span>) )</div><div class="line">  {</div><div class="line">    <span class="keywordflow">if</span>(myparam%2 != 0) {</div><div class="line">      <span class="keywordflow">throw</span> std::out_of_range{<span class="stringliteral">&quot;value for &#39;myparam&#39; parameter is not even&quot;</span>};</div><div class="line">    }</div><div class="line">  }</div><div class="line">  <span class="comment">// other code omitted</span></div><div class="line"> <span class="keyword">private</span>:</div><div class="line">  <span class="keywordtype">int</span> myparam;</div><div class="line">};</div></div><!-- fragment --><p>You should prefer to initialize parameter values in the constructor's initializer list, with further validation, if required, in the constructor body. Errors must be handled by throwing an exception derived from <code>std::exception</code>.</p>
<h1><a class="anchor" id="additionallibraries"></a>
Using Additional Libraries in Your Module </h1>
<p>The <code>flreconstruct</code> program provides the needed libraries to run core modules, specifically the minimal set:</p>
<ul>
<li>Falaise</li>
<li>Bayeux</li>
<li><a href="https://www.boost.org">Boost</a><ul>
<li>filesystem</li>
<li>system</li>
<li>serialization</li>
<li>iostreams</li>
<li>regex</li>
</ul>
</li>
<li><a href="https://www.gnu.org/software/gsl/">GSL</a></li>
<li><a href="http://proj-clhep.web.cern.ch/proj-clhep/">CLHEP</a></li>
<li><a href="https://root.cern.ch/doc/v612/modules.html">ROOT</a><ul>
<li>Core</li>
<li>RIO</li>
<li>Hist</li>
<li>MathCore</li>
<li>Matrix</li>
<li>Net</li>
<li>Tree</li>
<li>Thread</li>
</ul>
</li>
<li><a href="https://doc.qt.io/qt-5.10/qtcore-index.html">Qt5 QtCore</a></li>
</ul>
<p>Linking your module to the <code>Falaise::FalaiseModule</code> target in <code>target_link_libraries</code> ensures that your module uses the appropriate headers at compile time, and the correct symbols at runtime. If your module requires use of additional libraries, then you will need to get CMake to locate these and then link them to your module.</p>
<p>In the most common case of using non-core libraries from the ROOT package, then the <code>find_package</code> step would be modified to:</p>
<div class="fragment"><div class="line"># Find Falaise first, which ensures we use correct ROOT</div><div class="line">find_package(Falaise REQUIRED)</div><div class="line"></div><div class="line"># Find ROOT after Falaise, which guarantees use of same ROOT, but configure extra components</div><div class="line"># in this case, TMVA.</div><div class="line">find_package(ROOT REQUIRED TMVA)</div></div><!-- fragment --><p>The module can then be linked to the additional library by adding it in the <code>target_link_libraries</code> command:</p>
<div class="fragment"><div class="line">target_link_libraries(MyModule PUBLIC Falaise::FalaiseModule ${ROOT_TMVA_LIBRARY})</div></div><!-- fragment --><p>For other packages, <code>find_package</code> followed by <code>target_link_libraries</code> can be used in the same fashion.</p>
<h1>Next Steps </h1>
<p>The above examples have illustrated the basic structures needed to implement a module and load it into <code>flreconstruct</code>.</p>
<p>Practical modules will access the event object passed to them, process it and then write information back into the event record. <a class="el" href="workingwitheventrecords.html">Using the event data model in modules is covered in a dedicated tutorial</a>.</p>
<p>Modules may also need access to global data such as run conditions. FLReconstruct uses the concept of "Services" to provide such data, and <a class="el" href="usingservices.html">a tutorial on using services in modules is provided</a>.</p>
<p>Modules should also always be documented so that users have a clear picture of the task performed by the module and its configurable parameters. <a class="el" href="documentingflreconstructmodules.html">A tutorial on documenting modules using the builtin Falaise/Bayeux tools</a> is available.</p>
<p>Though modules for FLReconstruct may not be directly integrated in Falaise, for consistency and maintanability their code should use the <a href="https://github.com/SuperNEMO-DBD/Falaise/blob/develop/documentation/development/CodingStandards.md#">Falaise coding standards</a> </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
